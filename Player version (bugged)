# Player script with a freed object error within LevelManager not calling the PlayerStart Node2D
class_name Player
extends CharacterBody2D

# Constants
const SPEED = 200.0
const DASH_SPEED = 200.0
const DASH_TIME = 0.2
const JUMP_VELOCITY = -300.0
const MAX_JUMPS = 2
const DECELERATION = 1000.0
const ROTATION_SPEED = 360.0  # Degrees per second
const ANIMATION_DURATION : float = 0.5  # Duration of the second animation
const GAME_OVER_SCREEN = "res://GUI/game_over.tscn" 
# Variables
var gravity = ProjectSettings.get_setting("physics/2d/default_gravity")
var jumps_left = MAX_JUMPS
var dash_time_left = 0.0
var dashing = false
var animation_timer = 0.0
var play_animation = false
var game_over = false
var can_control : bool = true
# Reference to the AnimatedSprite2D
@export var sprite: AnimatedSprite2D

# Called when the node enters the scene tree for the first time.
func _ready():
	sprite = $AnimatedSprite2D

	# Play the initial animation
	sprite.play("player_idle")  # Replace "player_idle" with the name of your idle animation

func _physics_process(delta):
	var velocity = get_velocity() # Ensure you get the current velocity
	if not can_control: return
	
	# Handle dash logic
	if dashing:
		dash_time_left -= delta
		sprite.rotation_degrees += ROTATION_SPEED * delta  # Continuously spin the sprite
		if dash_time_left <= 0:
			dashing = false
			sprite.rotation_degrees = 0  # Reset rotation after dashing
	else:
		# Normal movement and gravity handling if not dashing
		if not is_on_floor():
			velocity.y += gravity * delta
			sprite.play("jump")  # Play jumping animation if in air and not dashing
		else:
			jumps_left = MAX_JUMPS

		# Handle jump
		if Input.is_action_just_pressed("jump") and jumps_left > 0:
			velocity.y = JUMP_VELOCITY
			jumps_left -= 1
			sprite.play("jump")  # Play jumping animation when jumping
		if Input.is_action_pressed("jump"):
			sprite.play("roll")
		 
		# Get the input direction and handle the movement/deceleration
		var move_input = Input.get_axis("move_left", "move_right")
		if move_input != 0:
			velocity.x = move_input * SPEED

			# Flip the sprite based on movement direction
			sprite.flip_h = move_input < 0

			# Play running animation
			sprite.play("roll")  # Replace "run" with the name of your running animation
		else:
			velocity.x = move_toward(velocity.x, 0, SPEED * delta)
			
			# Apply deceleration toa minimize sliding
			if velocity.x > 0:
				velocity.x = max(velocity.x - DECELERATION * delta, 0)
			elif velocity.x < 0:
				velocity.x = min(velocity.x + DECELERATION * delta, 0)
			
			# Play idle animation if on the ground and not moving
			if is_on_floor():
				sprite.play("player_idle") 
				 
			if not is_on_floor():
					velocity.y += gravity * delta
					sprite.play("roll")
	# Handle dash input
	if Input.is_action_just_pressed("dash") and not dashing:
		dashing = true
		dash_time_left = DASH_TIME

		# Calculate dash direction towards the cursor
		var mouse_position = get_global_mouse_position()
		var dash_direction = (mouse_position - global_position).normalized()

		# Flip the sprite based on dash direction
		sprite.flip_h = dash_direction.x < 0

		# Set dash velocity
		velocity = dash_direction * DASH_SPEED
		sprite.play("roll")  # Replace "dash" with the name of your dash animation
# Start the animation timer
		animation_timer = ANIMATION_DURATION
		play_animation = true

		# Handle animation playback
		if play_animation:
			animation_timer -= delta
		if animation_timer <= 0:
			sprite.play("roll")  # Replace "dash_repeat" with the name of your second animation

	set_velocity(velocity)
	move_and_slide()

# Function to handle player death
func handle_danger() -> void:
	print("player died!")
	visible = false
	can_control = false

	# Create a new Timer instance for handling the delay before respawn
	var timer = Timer.new()
	timer.wait_time = 1
	timer.one_shot = true

	# Use a callable to connect the timeout signal to the reset_player function
	timer.connect("timeout", Callable(self, "_on_timeout"))
	add_child(timer)
	timer.start()

# Function to handle timeout and reset player
func _on_timeout() -> void:
	reset_player()

# Function to reset the player position
func reset_player() -> void:
	# Check if LevelManager's loaded level is valid
	if LevelManager.loaded_level:
		print("LevelManager loaded level: ", LevelManager.loaded_level)
		# Ensure the level_start_pos is valid
		if LevelManager.loaded_level.level_start_pos:
			print("Player start position: ", LevelManager.loaded_level.level_start_pos)
			global_position = LevelManager.loaded_level.level_start_pos.global_position
			visible = true
			can_control = true
		else:
			print("Error: Level start position is not defined in the loaded level.")
	else:
		print("Error: LevelManager loaded level is not valid.")
